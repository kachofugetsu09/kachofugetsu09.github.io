# **Network Edge 网络边缘**

## **Host: Clients and Servers 主机：客户端和服务器**

- **Servers** are often located in data centers.  
    **服务器** 通常位于数据中心。
- **Clients** are end-user devices such as PCs, smartphones, etc.  
    **客户端** 是终端用户设备，如PC、智能手机等。

## **Access Network 接入网络**

### **Types of Access Networks 接入网络的类型**

1. **Residential Access Network (居民接入网络)**
    - Provides internet access to homes.  
        为家庭提供互联网接入。
2. **Institutional Access Network (机构接入网络)**
    - Used by organizations like schools and companies.  
        由学校、公司等机构使用。
3. **Mobile Access Network (移动接入网络)**
    - Enables wireless access via cellular networks.  
        通过蜂窝网络实现无线接入。

### **Cable Access Networks 电缆接入网络**

- **Asymmetric** : Transmits data faster in the downstream direction.  
    **不对称** ：在下游方向传输数据更快。
- **Shared Networks** : Multiple users share the same cable infrastructure.  
    **共享网络** ：多个用户共享相同的电缆基础设施。

---

# **Host Sending Function 主机发送功能**

1. **Takes Application Message 获取应用层消息**
    
    - Breaks it into smaller chunks called **packets** of length **L bits** .  
        将其分解为更小的块，称为长度为**L比特的数据包** 。
    - Transmits the packet into the access network at a transmission rate **R** .  
        以传输速率**R** 将数据包发送到接入网络。
2. **Packet Transmission Delay 数据包传输延迟**
    
    - Formula: **L/R**  
        公式：**L/R**

---

# **Guided vs Unguided Media 导引介质与非导引介质**

## **Guided Media 导引介质**

- Signals propagate in solid media like copper, fiber, or coax.  
    信号在固体介质中传播，例如铜线、光纤或同轴电缆。

## **Unguided Media 非导引介质**

- Signals propagate freely, such as radio waves.  
    信号自由传播，例如无线电波。
- No physical wire.  
    没有物理线路。
- Broadcast capability.  
    广播能力。

---

# **Network Core 网络核心**

## **Key Components 核心组件**

- **Interconnected Routers** : Form the core of the network.  
    **互联路由器** ：构成网络的核心。
- The network core is essentially a "network of networks."  
    网络核心本质上是一个“网络的网络”。

## **Two Key Functions 两个关键功能**

1. **Forwarding（Switching) 转发**
    
    - Move arriving packets from the router's input link to the appropriate output link.  
        将到达的数据包从路由器的输入链路移动到适当的输出链路。
    - Based on the destination address in the arriving packet's header.  
        基于到达数据包头部的目标地址。
    - A **local action** .  
        一个**本地操作** 。
2. **Routing 路由**
    
    - Determine source-destination paths taken by packets using routing algorithms.  
        使用路由算法确定数据包的源到目标路径。
    - A **global action** .  
        一个**全局操作** 。

## **Packet Switching 数据包交换**

- **Store and Forward 存储转发**
    - Entire packets must arrive at the router before they can be transmitted on the next link.  
        整个数据包必须先到达路由器，然后才能在下一个链路上传输。
- **Queueing 排队**
    - Packets may queue in routers due to input transmission speed being faster than output transmission speed.  
        由于输入传输速度比输出传输速度快，数据包可能会在路由器中排队。
    - Packet loss may occur during this process.  
        在此过程中可能会发生数据包丢失。

## **Circuit Switching 电路交换**

- **Dedicated Resources 专用资源**
    - No sharing, circuit-like performance.  
        不共享，类似电路的性能。
- Commonly used in traditional telephone networks.  
    传统电话网络中常用。
### **FDM (Frequency Division Multiplexing) 频分复用**
- **Definition**: Divides the available bandwidth into multiple frequency bands, each carrying a separate signal.  
  **定义**：将可用带宽划分为多个频段，每个频段传输一个独立的信号。
- **Analogy**: Like different radio stations broadcasting on different frequencies.  
  **类比**：就像不同的广播电台在不同的频率上广播。

### **TDM (Time Division Multiplexing) 时分复用**
- **Definition**: Divides time into fixed-length slots, allowing multiple signals to share the same channel by taking turns.  
  **定义**：将时间划分为固定长度的时间片，通过轮流使用通道来实现多路信号共享。
- **Analogy**: Like people taking turns speaking in a meeting.  
  **类比**：就像人们在会议中轮流发言。

## **Advantages of Packet Switching 数据包交换的优势**

- Good at handling bursty data (sometimes has data to send, sometimes not).  
    善于处理突发性数据（有时有数据发送，有时没有）。
- Resource sharing.  
    资源共享。
- Simpler, no call setup.  
    更简单，无需呼叫建立。

---

# **Internet Structure: A "Network of Networks" 互联网结构：一个“网络的网络”**

## **1. Access ISPs 接入ISP**

- **Definition** : Provide direct internet connection to end-users.  
    **定义** ：为终端用户提供直接的互联网连接。
- **Connection** : Connect to Regional ISPs or directly to IXPs.  
    **连接** ：接入区域ISP或直接连接到IXP。

## **2. Regional ISPs 区域ISP**

- **Definition** : Mid-sized networks covering specific geographic areas.  
    **定义** ：覆盖特定地理区域的中型网络。
- **Connection** : Connect Access ISPs to Tier-1 ISPs or IXPs.  
    **连接** ：将接入ISP连接到一级ISP或IXP。

## **3. Internet Exchange Points (IXPs) 互联网交换点**

- **Definition** : Neutral locations where multiple networks exchange traffic.  
    **定义** ：多个网络交换流量的中立地点。
- **Connection** : Allow Regional ISPs, Content Providers, and Tier-1 ISPs to interconnect.  
    **连接** ：允许区域ISP、内容提供商和一级ISP互联。

## **4. Tier-1 ISPs 一级ISP**

- **Definition** : Large global backbone networks that cover multiple countries/regions.  
    **定义** ：覆盖多个国家/地区的大型全球骨干网络。
- **Connection** : Interconnect with other Tier-1 ISPs via peering, and connect to Regional ISPs or IXPs.  
    **连接** ：通过对等互联与其他一级ISP互联，并连接到区域ISP或IXP。

## **5. Content Provider Networks 内容提供商网络**

- **Definition** : Private networks owned by content providers (e.g., Google, Netflix).  
    **定义** ：由内容提供商（如Google、Netflix）拥有的私有网络。
- **Connection** : Bypass Tier-1 ISPs by connecting directly to IXPs or Regional ISPs.  Can connecting directly to access ISPs.
    **连接** ：通过直接连接到IXP或区域ISP，绕过一级ISP。可以直接连接接入ISPs。

# **End-to-End Connection Architecture 端到端连接架构**
![9b67b0fa085df5832f0591baf07a48ad.png](https://java358864.oss-cn-beijing.aliyuncs.com/2025/02/20/3350325fcbc14ae49f88f80978d49c29.png)


# **Performance 性能**

## **Components of Network Delay 网络延迟的组成部分**

1. **Processing Delay 处理延迟**
   - **Definition:** Time taken for tasks such as forwarding table lookup, forwarding a packet through the switch, and performing integrity checks.  
     **定义:** 用于转发表查找、通过交换机转发数据包以及执行完整性检查等任务的时间。

2. **Queueing Delay 排队延迟**
   - **Definition:** Time spent waiting at the output link for transmission.  
     **定义:** 在输出链路上传输时等待的时间。
   - **Formula:** $\frac{aL}{R}$  
     **公式:** $\frac{aL}{R}$
     - If this ratio exceeds 1, the delay becomes significant and may approach infinity.  
       如果该比率超过 1，延迟将变得显著，甚至可能接近无限大。

3. **Transmission Delay 传输延迟**
   - **Definition:** Time required to push all the packet's bits into the link.  
     **定义:** 将数据包的所有比特推入链路所需的时间。
   - **Formula:** $\frac{L}{R}$  
     **公式:** $\frac{L}{R}$

4. **Propagation Delay 传播延迟**
   - **Definition:** Time taken for a bit to travel across the physical link.  
     **定义:** 一个比特通过物理链路传播所需的时间。
   - **Formula:** $\frac{d}{s}$  
     **公式:** $\frac{d}{s}$
     - Where $d$ is the length of the physical link and $s$ is the propagation speed.  
       其中，$d$ 是物理链路的长度，$s$ 是传播速度。

---

## **Traceroute: Analyzing Network Delays Traceroute：分析网络延迟**

1. Sends three packets that will reach router $i$ on the path towards the destination.  
   发送三个数据包，这些数据包将到达通往目的地路径上的第 $i$ 个路由器。
   
2. Router $i$ will return the packets to the sender.  
   第 $i$ 个路由器将返回数据包给发送方。

3. The sender measures the time interval between transmission and reply.  
   发送方测量发送和回复之间的时间间隔。

---

## **Packet Loss 数据包丢失**

1. The queue preceding the link in the buffer has finite capacity.  
   缓冲区中链路前的队列容量有限。

2. A packet arriving at a full queue is dropped (lost).  
   到达已满队列的数据包将被丢弃（丢失）。

3. A lost packet may or may not be retransmitted.  
   丢失的数据包可能会或可能不会被重新传输。

---

## **Throughput 吞吐量**

- **Definition:** The rate (bits/time unit) at which bits are being sent from the sender to the receiver.  
  **定义:** 从发送方到接收方发送比特的速率（比特/时间单位）。

### **Types of Throughput 吞吐量的类型**

1. **Instantaneous Throughput 瞬时吞吐量**
   - **Definition:** The rate at a given point in time.  
     **定义:** 在某一特定时刻的速率。

2. **Average Throughput 平均吞吐量**
   - **Definition:** The rate over a longer period of time.  
     **定义:** 在较长时间内的平均速率。

---

# **Layering and Encapsulation 分层与封装**

## **Layering 分层**

1. **Explicit structure allows identification, relationship of system's pieces**  
   明确的结构允许识别系统各部分及其关系。

2. **Modularization eases maintenance, updating of system**  
   模块化使系统的维护和更新更加容易。

![](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/8c1851208d59563349283be48329690a.png)

---

### **Application Layer 应用层**

- **Application exchanges messages to implement some application service using services of the transport layer.**  
  应用层通过传输层的服务交换消息以实现某些应用服务。

---

### **Transport Layer 传输层**

- **Transport layer protocol transfers M (message) from one process to another using services of the network layer.**  
  传输层协议利用网络层的服务将消息 M 从一个进程传输到另一个进程。

- **Transport layer protocol encapsulates application layer message M with transport layer header Ht to create a transport-layer segment.**  
  传输层协议将应用层消息 M 封装上传输层头部 Ht，形成传输层段（segment）。

---

### **Network Layer 网络层**

- **Network layer protocol transfers transport layer segment from one host to another using link layer services.**  
  网络层协议利用链路层的服务将传输层段从一个主机传输到另一个主机。

- **Network layer protocol encapsulates transport layer segment with network layer header Hn to create a network layer datagram, which is the protocol data unit used at the network layer.**  
  网络层协议将传输层段封装上网路层头部 Hn，形成网络层数据报（datagram），这是网络层使用的协议数据单元。

---

### **Link Layer 链路层**

- **Link layer protocol transfers network layer datagram from one host to a neighboring host using physical layer services.**  
  链路层协议利用物理层的服务将网络层数据报从一个主机传输到相邻主机。

- **Link layer protocol encapsulates network layer datagram with link layer header Hl to create a link layer frame.**  
  链路层协议将网络层数据报封装上链路层头部 Hl，形成链路层帧（frame）。

---

## **Encapsulation 封装**

![](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/55848cc5065933864e2634487089e676.png)

- **Encapsulation Process:**  
  **封装过程：**
  - **Application Layer:** Message M  
    **应用层：** 消息 M
  - **Transport Layer:** Adds Header Ht → Segment  
    **传输层：** 添加头部 Ht → 段（Segment）
  - **Network Layer:** Adds Header Hn → Datagram  
    **网络层：** 添加头部 Hn → 数据报（Datagram）
  - **Link Layer:** Adds Header Hl → Frame  
    **链路层：** 添加头部 Hl → 帧（Frame）
---

# **Principles of the Application Layer 应用层原理**

## **Client-Server Paradigm 客户端-服务器模型**
- **Server 服务器:**
  - Always-on host.  
    始终在线的主机。
  - Permanent IP address.  
    永久 IP 地址。
  - Often located in data centers for scalability.  
    通常位于数据中心以实现可扩展性。

- **Clients 客户端:**
  - Contact and communicate with the server.  
    联系并和服务器通信。
  - May be intermittently connected.  
    可能间歇性连接。
  - May have dynamic IP addresses.  
    可能具有动态 IP 地址。
  - Do not communicate directly with each other.  
    不直接相互通信。

---

## **Peer-to-Peer Architecture 对等架构**
- No always-on server.  
  没有始终在线的服务器。
- Arbitrary end systems communicate directly.  
  任意终端系统直接通信。
- Peers request services from other peers and provide services in return.  
  对等节点从其他对等节点请求服务，并提供服务作为回报。
  - **Self-scalability 自我扩展性:** New peers bring new service capacity.  
    新节点带来新的服务能力。

---

## **Processes Communicating 进程通信**
- **Process 进程:** A program running within a host.  
  在主机内运行的程序。
- **Within the same host 同一主机内:** Two processes communicate using inter-process communication (provided by the OS).  
  两个进程通过操作系统提供的进程间通信进行通信。
- **Between different hosts 不同主机之间:** Processes communicate by exchanging messages.  
  进程通过交换消息进行通信。
- **Client Process 客户端进程:** Initiates communication.  
  发起通信。
- **Server Process 服务器进程:** Waits to be contacted.  
  等待被联系。

---

## **Sockets 套接字**
- A process sends/receives messages to/from its socket.  
  进程通过其套接字发送/接收消息。
- **Socket Analogy 套接字类比:** Like a door.  
  类似于一扇门。
  - Sending process shoves a message out the door.  
    发送进程将消息推出门外。
  - The sending process relies on the transport infrastructure to deliver the message to the receiving process's socket.  
    发送进程依赖传输基础设施将消息传递到接收进程的套接字。

---

## **Addressing Processes 进程寻址**
- To receive messages, a process must have an identifier.  
  为了接收消息，进程必须有一个标识符。
  - Identifier includes both the **IP address IP地址** and **port number 端口号**.
  - Each host device has a unique 32-bit IP address.  
    每台主机设备都有一个唯一的 32 位 IP 地址。
- **Types of Messages Exchanged 消息类型:**
  - Request 请求, Response 响应.
- **Message Syntax 消息语法:** Defines the fields in messages and how fields are delineated.  
  定义消息中的字段以及字段如何划分。
- **Message Semantics 消息语义:** Defines the meaning of information in fields.  
  定义字段中信息的含义。

---

## **Open vs. Proprietary Protocols 开放协议与专有协议**
- **Open Protocols 开放协议:** Defined in RFCs (Request for Comments).  
  定义在 RFC（征求意见稿）中。
- **Proprietary Protocols 专有协议:** Developed by specific organizations or companies.  
  由特定组织或公司开发。

---

## **Features Different Services Require 不同服务所需的功能**
- Data Integrity 数据完整性
- Timing 时间要求
- Throughput 吞吐量

---

## **TCP vs. UDP TCP与UDP对比**

### **TCP 特性**
- **Reliable Transport 可靠传输:** Ensures reliable data transfer between sending and receiving processes.  
  确保发送和接收进程之间的可靠数据传输。
- **Flow Control 流量控制:** Prevents the sender from overwhelming the receiver.  
  防止发送方压垮接收方。
- **Congestion Control 拥塞控制:** Throttles the sender when the network is overloaded.  
  当网络过载时限制发送方。
- **Connection-Oriented 面向连接:** Requires setup between client and server processes.  
  需要在客户端和服务器进程之间建立连接。
- **Does Not Provide 不提供:**
  - Timing guarantees 时间保证.
  - Minimum throughput guarantees 最小吞吐量保证.
  - Security 安全性.

### **UDP 特性**
- **Unreliable Data Transfer 不可靠传输:** Does not guarantee delivery.  
  不保证交付。
- **Does Not Provide 不提供:**
  - Reliability 可靠性.
  - Flow control 流量控制.
  - Congestion control 拥塞控制.
  - Timing guarantees 时间保证.
  - Throughput guarantees 吞吐量保证.
  - Security 安全性.
  - Connection setup 连接建立.

---

## **Securing TCP 安全的TCP**

### **Vanilla TCP & UDP Sockets 普通TCP和UDP套接字**
- No encryption.  
  没有加密。

### **Transport Layer Security (TLS) 传输层安全协议**
- Provides encrypted TCP connections.  
  提供加密的 TCP 连接。
- **Data Integrity 数据完整性:** Ensures that data is not tampered with during transmission.  
  确保数据在传输过程中未被篡改。
- **End-Point Authentication 端点认证:** Verifies the identity of the communicating parties.  
  验证通信双方的身份。
---
# **Web and HTTP 网络与HTTP**

## **Web Page Composition 网页组成**
- A web page consists of multiple objects, each of which can be stored on different servers.  
  **网页由多个对象组成，每个对象可以存储在不同的服务器上。**
- The base HTML file includes references to other objects, each addressable by a URL.  
  **基础HTML文件包含对其他对象的引用，每个对象都可以通过URL访问。**

---

## **HTTP Protocol HTTP协议**
- **Client/Server Model 客户端/服务器模型:**
  - **Client 客户端:** A browser that requests, receives (using the HTTP protocol), and displays web objects.  
    **浏览器请求、接收（使用HTTP协议）并显示网页对象。**
  - **Server 服务器:** A web server sends (using the HTTP protocol) objects in response to requests.  
    **Web服务器响应请求并发送对象。**

- **HTTP Uses TCP HTTP基于TCP:**
  - The client initiates a TCP connection to the server on port 80.  
    **客户端在端口80上向服务器发起TCP连接。**
  - The server accepts the TCP connection from the client.  
    **服务器接受来自客户端的TCP连接。**
  - HTTP messages are exchanged between the browser (HTTP client) and the web server (HTTP server).  
    **HTTP消息在浏览器（HTTP客户端）和Web服务器（HTTP服务器）之间交换。**
  - The TCP connection is closed after communication.  
    **通信完成后关闭TCP连接。**

---

## **Stateless Protocol 无状态协议**
- The server maintains no information about past client requests.  
  **服务器不会保留任何关于过去客户端请求的信息。**

---

## **Non-Persistent vs. Persistent HTTP 非持久性与持久性HTTP**

### **Non-Persistent HTTP 非持久性HTTP**
1. TCP connection opened.  
   **TCP连接打开。**
2. At most one object is sent over the TCP connection.  
   **最多一个对象通过TCP连接发送。**
3. TCP connection closed.  
   **TCP连接关闭。**

- **Response Time 响应时间:**  
  Non-persistent HTTP response time = 2RTT + file transmission time.  
  **非持久性HTTP响应时间 = 2RTT + 文件传输时间。**

### **Persistent HTTP 持久性HTTP (HTTP/1.1)**
1. TCP connection opened to a server.  
   **向服务器打开TCP连接。**
2. Multiple objects can be sent over a single TCP connection.  
   **多个对象可以通过单个TCP连接发送。**
3. TCP connection closed.  
   **TCP连接关闭。**

- **Advantages 优点:**  
  - The server leaves the connection open after sending a response.  
    **服务器在发送响应后保持连接打开。**
  - As little as one RTT for all referenced objects, cutting response time in half.  
    **所有引用对象只需一个RTT，将响应时间减半。**

---

## **RTT (Round-Trip Time) 往返时间**
- The time it takes for a small packet to travel from the client to the server and back.  
  **小数据包从客户端到服务器再返回所需的时间。**

---

## **HTTP Request Message Format HTTP请求消息格式**
![](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/f30771e827f4bd7b8fe655e32dd4a0f4.png)

---

## **Other HTTP Request Methods 其他HTTP请求方法**

### **POST Method POST方法**
- Web pages often include form inputs.  
  **网页通常包含表单输入。**
- User input is sent from the client to the server in the entity body of the HTTP POST request message.  
  **用户输入通过HTTP POST请求消息的实体主体发送到服务器。**

### **GET Method GET方法**
- Includes user data in the URL field of the HTTP GET request message (following a '?').  
  **在HTTP GET请求消息的URL字段中包含用户数据（紧跟在'?'后）。**

### **PUT Method PUT方法**
- Uploads a new file to the server.  
  **上传新文件到服务器。**
- Completely replaces the file at the specified URL with the content in the entity body of the HTTP PUT request message.  
  **完全替换指定URL处的文件为HTTP PUT请求消息实体主体中的内容。**

### **HEAD Method HEAD方法**
- Returns the result of the GET method without including the entity body.  
  **返回GET方法的结果，但不包含实体主体。**

---

## **HTTP Response Status Codes HTTP响应状态码**
- **200 OK:** Request succeeded.  
  **请求成功。**
- **301 Moved Permanently:** Resource has been permanently moved to a new URL.  
  **资源已永久移动到新URL。**
- **400 Bad Request:** The server could not understand the request due to invalid syntax.  
  **由于语法错误，服务器无法理解请求。**
- **404 Not Found:** The requested resource could not be found.  
  **请求的资源未找到。**
- **505 HTTP Version Not Supported:** The server does not support the HTTP version used in the request.  
  **服务器不支持请求中使用的HTTP版本。**

---

## **Maintaining User/Server State 维护用户/服务器状态: Cookies**
1. **Cookie header line in HTTP response message.**  
   **HTTP响应消息中的Cookie头部行。**
2. **Cookie header line in the next HTTP request message.**  
   **下一次HTTP请求消息中的Cookie头部行。**
3. **Cookie file kept on the user's host, managed by the user's browser.**  
   **存储在用户主机上的Cookie文件，由用户浏览器管理。**
4. **Back-end database at the web site.**  
   **网站的后端数据库。**

---

## **Web Caches 网络缓存**
- The browser sends all HTTP requests to the cache first. If the object is in the cache, it returns it; otherwise, it retrieves the object from the server and then returns it to the client.  
  **浏览器首先将所有HTTP请求发送到缓存。如果对象在缓存中，则返回它；否则，从服务器检索对象并将其返回给客户端。**
- Acts as both a client and a server.  
  **同时充当客户端和服务器。**
- Reduces response time for client requests.  
  **减少客户端请求的响应时间。**
- Reduces traffic on an institution's access link.  
  **减少机构接入链路上的流量。**
- The Internet is dense with caches.  
  **互联网中充满了缓存。**

---

## **Conditional HTTP GET 条件性HTTP GET**
- **Client 客户端:** Specify the date of the cached copy in the HTTP request.  
  **在HTTP请求中指定缓存副本的日期。**
  - `If-Modified-Since: <date>`  
    **如果自<日期>以来已修改：**
- **Server 服务器:** If the cached copy is up-to-date, the response contains no object (status code 304).  
  **如果缓存副本是最新的，响应中不包含对象（状态码304）。**

---

## **HTTP/2 and HTTP/3 HTTP/2与HTTP/3**

### **HTTP/2**
- Objects are divided into frames, and frame transmission is interleaved.  
  **对象被划分为帧，并且帧传输是交错进行的。**

### **HTTP/3**
- Adds security per object, error handling, and congestion control over UDP.  
  **为每个对象添加安全性、错误处理和基于UDP的拥塞控制。**

---

# **The Domain Name System (DNS)**
## **Overview**
- **DNS is an Application Layer Protocol:** Hosts and DNS servers communicate to resolve names.  
  **DNS是一种应用层协议：主机和DNS服务器通过通信来解析名称。**  
- **Primary Role:** Provides translation between names, services, and IP addresses.  
  **主要作用：提供名称、服务和IP地址之间的转换。**  
- **Distributed Database:** The DNS is a distributed database implemented in a hierarchy of many name servers.  
  **分布式数据库：DNS是一个由许多名称服务器组成的分层分布式数据库。**

## **DNS Functions**
1. **Hostname-to-IP-address Translation:** Resolves domain names (e.g., `www.amazon.com`) to IP addresses.  
   **主机名到IP地址的转换：将域名（如`www.amazon.com`）解析为IP地址。**  
2. **Host Aliasing:**  
   - **Canonical Names:** Primary names for hosts.  
     **规范名称：主机的主要名称。**  
   - **Alias Names:** Alternative names for hosts.  
     **别名：主机的替代名称。**  
3. **Mail Server Aliasing:** Maps mail server names to their canonical names.  
   **邮件服务器别名：将邮件服务器名称映射到其规范名称。**  
4. **Load Distribution:**  
   - **Replicated Web Servers:** Many IP addresses correspond to one name.  
     **复制的Web服务器：多个IP地址对应一个名称。**  
   - **Load Balancing:** DNS rotates among possible IP addresses, returning one as the primary service.  
     **负载均衡：DNS在可能的IP地址之间轮转，返回其中一个作为主要服务。**

## **DNS Structure**
- **Hierarchical and Distributed:**  
  - **Avoids Single Point of Failure:** No central server handles all queries.  
    **避免单点故障：没有中央服务器处理所有查询。**  
  - **Handles Traffic Volume:** Distributes query load across multiple servers.  
    **处理流量：将查询负载分布到多个服务器上。**  
  - **Reduces Latency:** Local DNS servers cache results, improving response times.  
    **减少延迟：本地DNS服务器缓存结果，提高响应速度。**  
  - **Easier Maintenance:** Decentralized structure simplifies updates and management.  
    **易于维护：去中心化结构简化了更新和管理。**
---

## **DNS Resolution Process**
For `www.amazon.com`:  
对于`www.amazon.com`：  
1. **Client queries root server to find `.com` DNS server.**  
   **客户端查询根服务器以找到`.com` DNS服务器。**  
2. **Client queries `.com` DNS server to get `amazon.com` DNS server.**  
   **客户端查询`.com` DNS服务器以获取`amazon.com` DNS服务器。**  
3. **Client queries `amazon.com` DNS server to get the IP address for `www.amazon.com`.**  
   **客户端查询`amazon.com` DNS服务器以获取`www.amazon.com`的IP地址。**  

- **Root Servers:** Do not provide translation services directly but guide clients to the appropriate DNS servers.  
  **根服务器：不直接提供翻译服务，而是引导客户端找到合适的DNS服务器。**  
- **Local DNS Server:** When a host makes a DNS query, it is sent to its local DNS server.  
  **本地DNS服务器：当主机发出DNS查询时，查询会被发送到其本地DNS服务器。**  
  - **Caching:** DNS information is cached to improve response times. However, cache entries may become outdated.  
    **缓存：DNS信息会被缓存以提高响应速度，但缓存条目可能会过时。**

## **DNS Record Format**
- **RR Format:** `(Name, Value, Type, TTL)`  
  **资源记录格式：`(名称, 值, 类型, 生存时间)`**  
  - **Example:**  
    - `www.amazon.com, 192.0.2.1, A, 3600`  
      **示例：`www.amazon.com, 192.0.2.1, A, 3600`**

## **DNS Protocol Messages**
- **Query and Reply Messages:** Both have the same format.  
  **查询和回复消息：两者具有相同的格式。**

## **DNS Security**
- **DDoS Attacks:** DNS servers can be targeted by Distributed Denial of Service (DDoS) attacks.  
  **DDoS攻击：DNS服务器可能成为分布式拒绝服务（DDoS）攻击的目标。**  
- **Spoofing Attacks:** Attackers may attempt to spoof DNS responses to redirect traffic.  
  **欺骗攻击：攻击者可能试图伪造DNS响应以重定向流量。**  
---

## **Video Streaming / 视频流**

### **Video Characteristics / 视频特性**

Streaming video poses unique challenges due to its scale and heterogeneity:  
视频流因其规模和异构性而面临独特的挑战：

- **Scale:** Delivering high-quality video to millions of users simultaneously requires significant infrastructure, including Content Delivery Networks (CDNs) and robust server architectures.  
    **扩展性：同时向数百万用户提供高质量视频需要庞大的基础设施支持，包括内容分发网络（CDN）和强大的服务器架构。**
    
    - **Explanation:** High-definition (HD) and ultra-high-definition (UHD) videos demand substantial bandwidth and storage resources.  
        **解释：高清（HD）和超高清（UHD）视频需要大量的带宽和存储资源。**
- **Heterogeneity:** Users access content from different devices (mobile, PC, etc.) with varying bandwidths, screen resolutions, and processing capabilities.  
    **异构性：用户通过不同设备（手机、PC 等）访问内容，带宽、屏幕分辨率和处理能力差异较大。**
    
    - **Explanation:** For example, a mobile user on a 3G network may experience lower quality compared to a desktop user on a fiber-optic connection.  
        **解释：例如，使用 3G 网络的移动用户可能会比使用光纤连接的桌面用户体验到更低的质量。**


### **Video Encoding Types / 视频编码类型**

- **CBR (Constant Bit Rate):** Video encoding rate is fixed throughout the entire video stream.  
    **CBR（恒定比特率）：在整个视频流中，编码速率保持固定。**
    
    - **Advantages:** Predictable bandwidth usage makes it suitable for scenarios where network conditions are stable.  
        **优点：可预测的带宽使用使其适用于网络条件稳定的场景。**
    - **Disadvantages:** Inefficient for videos with varying complexity, as it allocates the same bitrate regardless of scene changes.  
        **缺点：对于复杂度变化的视频效率较低，因为它无论场景如何变化都分配相同的比特率。**
- **VBR (Variable Bit Rate):** Video encoding rate changes dynamically based on spatial (image detail) and temporal (motion) complexity.  
    **VBR（可变比特率）：视频编码速率根据空间（图像细节）和时间（运动）复杂度动态变化。**
    
    - **Advantages:** Allocates higher bitrates to complex scenes and lower bitrates to simple scenes, optimizing quality and file size.  
        **优点：为复杂场景分配更高的比特率，为简单场景分配更低的比特率，从而优化质量和文件大小。**
    - **Disadvantages:** Requires more sophisticated encoding algorithms and can lead to unpredictable bandwidth demands.  
        **缺点：需要更复杂的编码算法，并可能导致不可预测的带宽需求。**

---

### **Streaming Stored Video / 流式存储视频**

- **Buffering:** Temporary storage of video data before playback ensures smooth playout even if network conditions fluctuate.  
    **缓冲：在播放前临时存储视频数据，即使网络条件波动也能确保流畅播放。**
    
    - **Explanation:** Buffers act as a safety net, allowing the client to pre-load video data and compensate for delays or packet loss.  
        **解释：缓冲区充当安全网，允许客户端预加载视频数据，以补偿延迟或丢包。**
- **Playout:** Continuous playback of video at the client side ensures a seamless viewing experience.  
    **播放：客户端连续播放视频，确保无缝观看体验。**
    
    - **Explanation:** Playout timing must match the original video timing to avoid interruptions or synchronization issues.  
        **解释：播放时间必须与原始视频时间匹配，以避免中断或同步问题。**

---

#### **Challenges / 挑战**

1. **Bandwidth Variability:** Server-to-client bandwidth fluctuates due to network congestion, leading to buffering or degraded video quality.  
    **带宽波动：由于网络拥塞，服务器到客户端的带宽会随时间变化，导致缓冲或视频质量下降。**
    
    - **Example:** A sudden spike in network traffic can cause video playback to pause while the buffer refills.  
        **示例：网络流量的突然激增可能导致视频播放暂停，直到缓冲区重新填满。**
2. **Packet Loss and Delay:** Congestion causes packet loss and delays, which can result in missing frames or audio-video desynchronization.  
    **丢包和延迟：拥塞导致丢包和延迟，可能导致帧丢失或音视频不同步。**
    
    - **Example:** Lost packets may require retransmission, introducing additional latency.  
        **示例：丢失的数据包可能需要重新传输，从而引入额外的延迟。**

---

#### **Solution / 解决方案**

- **Client-Side Buffering:** Smooths out playout timing by compensating for network-added delay and jitter.  
    **客户端缓冲：通过补偿网络引入的延迟和抖动来平滑播放曲线。**
    - **Explanation:** A larger buffer can handle more variability but increases initial loading time (playout delay).  
        **解释：更大的缓冲区可以应对更多波动，但会增加初始加载时间（播放延迟）。**

---

### **Dynamic Adaptive Streaming over HTTP (DASH) / 动态自适应流媒体协议**

#### **Server Side / 服务器端**

1. Divides video file into multiple chunks, typically a few seconds each.  
    **将视频文件分割为多个片段，通常每段几秒钟。**
    
    - **Explanation:** Chunk-based segmentation allows for efficient adaptation to changing network conditions.  
        **解释：基于片段的分割能够高效适应不断变化的网络条件。**
2. Encodes each chunk at multiple rates to support different bandwidths.  
    **对每个片段进行多速率编码，以支持不同的带宽。**
    
    - **Example:** A single video may have 480p, 720p, and 1080p versions of each chunk.  
        **示例：单个视频可能包含每个片段的 480p、720p 和 1080p 版本。**
3. Stores different rate encodings in separate files for easy retrieval.  
    **将不同速率的编码存储在单独的文件中，便于检索。**
    
    - **Explanation:** File separation simplifies the process of switching between quality levels.  
        **解释：文件分离简化了在不同质量级别之间切换的过程。**
4. Replicates files across various CDN nodes to reduce latency and improve availability.  
    **在不同的 CDN 节点上复制文件，以减少延迟并提高可用性。**
    
    - **Explanation:** CDNs distribute content geographically closer to users, minimizing load times.  
        **解释：CDN 将内容分布到离用户地理位置更近的地方，从而最小化加载时间。**
5. Provides a manifest file with URLs for different chunks, enabling clients to request specific segments.  
    **提供一个清单文件，包含不同片段的 URL，使客户端能够请求特定片段。**
#### **Client Side / 客户端**

- Periodically estimates server-to-client bandwidth to determine the optimal video quality.  
    **定期估算服务器到客户端的带宽，以确定最佳视频质量。**
    
    - **Explanation:** Bandwidth estimation helps the client adapt to changing network conditions in real-time.  
        **解释：带宽估算帮助客户端实时适应不断变化的网络条件。**
- Consults the manifest file to request one chunk at a time, selecting the appropriate quality level.  
    **参考清单文件，逐个请求片段，选择合适质量级别。**
    
    - **Example:** If bandwidth is low, the client requests a lower-quality chunk; if bandwidth improves, it switches to a higher-quality chunk.  
        **示例：如果带宽较低，客户端请求低质量片段；如果带宽改善，则切换到高质量片段。**
- Chooses the appropriate coding rate based on available bandwidth, ensuring smooth playback without buffering.  
    **根据可用带宽选择合适的编码速率，确保流畅播放且不出现缓冲。**
    
    - **Explanation:** Adaptive streaming minimizes interruptions by dynamically adjusting video quality.  
        **解释：自适应流媒体通过动态调整视频质量，最大限度地减少中断。**

---

## Socket Programming / 套接字编程**

### What Are Sockets? / 什么是套接字？

Sockets act as the bridge between the application layer and the transport layer.  
套接字是应用层和传输层之间的桥梁。

- **UDP Sockets:** Connectionless, lightweight, and faster but unreliable.  
    **UDP 套接字：无连接、轻量级且快速，但不可靠。**
- **TCP Sockets:** Connection-oriented, reliable, and ensures ordered delivery.  
    **TCP 套接字：面向连接、可靠，并确保有序交付。**


client:
```python
from socket import *  
  
serverName = 'localhost'  serverPort = 12000  
clientSocket = socket(AF_INET, SOCK_DGRAM)  
  
message = input('Input lowercase sentence: ')  clientSocket.sendto(message.encode(), (serverName, serverPort))  
  
modifiedMessage, serverAddress = clientSocket.recvfrom(2048)  
print(modifiedMessage.decode())  
  
clientSocket.close()
```

server:
```python
from socket import *  
serverPort = 12000  
serverSocket = socket(AF_INET, SOCK_DGRAM)  
serverSocket.bind(('', serverPort))  
print("The server is ready to receive")  
while True:  
    message, clientAddress = serverSocket.recvfrom(2048)  
    modifiedMessage = message.decode().upper()  
    serverSocket.sendto(modifiedMessage.encode(), clientAddress)
```
### **Creating TCP Sockets / 创建 TCP 套接字**

- **Server-Side Socket Creation / 服务器端套接字创建**  
    When creating a TCP socket, the server specifies its IP address and port number to listen for incoming client connections.  
    在创建 TCP 套接字时，服务器会指定其 IP 地址和端口号，以监听来自客户端的连接请求。
    
- **Client-Server Connection Establishment / 客户端与服务器连接建立**  
    When a client contacts the server, the server's TCP protocol creates a new socket specifically for communication with that particular client.  
    当客户端联系服务器时，服务器的 TCP 协议会为与该特定客户端的通信创建一个新的套接字。

client:
```python
from socket import *  
  
  
serverName ='localhost'  
serverPort = 12000  
clientSocket =socket(AF_INET, SOCK_STREAM)  
clientSocket.connect((serverName, serverPort))  
sentence = input('Input lowercase sentence:')  
clientSocket.send(sentence.encode())  
modifiedMessage = clientSocket.recv(1024)  
print('From Server:', modifiedMessage.decode())  
clientSocket.close()
```

server:
```python
from socket import *  
  
  
serverPort = 12000  
serverSocket = socket(AF_INET, SOCK_STREAM)  
serverSocket.bind(('', serverPort))  
serverSocket.listen(1)  
print("The server is ready to receive")  
while True:  
    connectionSocket, addr = serverSocket.accept()  
  
    sentence =connectionSocket.recv(1024).decode()  
    capitalizedSentence = sentence.upper()  
    connectionSocket.send(capitalizedSentence.encode())  
    connectionSocket.close()
```


---
## Transport Layer Actions / 传输层操作

### Sender / 发送方

1. **Passed an application layer message**  
    The sender receives a message from the application layer, which needs to be transmitted over the network.  
    **发送方从应用层接收需要通过网络传输的消息。**
    
2. **Determines segment header fields values**  
    The transport layer determines the necessary header fields such as source port, destination port, sequence number, etc.  
    **传输层确定必要的头部字段，如源端口、目标端口、序列号等。**
    
3. **Create segment**  
    The transport layer encapsulates the application-layer message into a segment by adding the header.  
    **传输层通过添加头部将应用层消息封装成段。**
    
4. **Passes segment to IP**  
    The segment is then passed to the IP layer for further processing and transmission.  
    **段随后被传递到 IP 层进行进一步处理和传输。**
    

### Receiver / 接收方

1. **Receives segment from IP**  
    The receiver gets the segment from the IP layer.  
    **接收方从 IP 层获取段。**
    
2. **Checks header values**  
    The transport layer checks the header values to ensure the segment is intended for the correct application.  
    **传输层检查头部值，以确保段是针对正确的应用程序的。**
    
3. **Extracts application-layer message**  
    The transport layer extracts the application-layer message from the segment.  
    **传输层从段中提取应用层消息。**
    
4. **Demultiplexes message up to application socket**  
    The message is delivered to the appropriate application socket based on the port number.  
    **根据端口号，消息被传递到适当的应用程序套接字。**
    

---

## Multiplexing and Demultiplexing / 多路复用与多路分解

### Multiplexing at Senders / 发送方的多路复用

Handle data from multiple sockets, add transport header.  
**处理来自多个套接字的数据，并添加传输层头部。**

- **Why multiplexing is needed?**  
    Many applications may be sending data through multiple sockets. TCP takes these messages and funnels them down into IP.  
    **为什么需要多路复用？**  
    许多应用程序可能通过多个套接字发送数据。TCP 会将这些消息收集起来并通过 IP 层发送出去。

### Demultiplexing at Receiver / 接收方的多路分解

Use header info to deliver received segments to correct socket.  
**使用头部信息将接收到的段传递到正确的套接字。**

- **Why demultiplexing is needed?**  
    Hosts receive datagrams that have payloads bound for different applications or protocols. The process of directing those payloads to the appropriate application or protocol is called demultiplexing.  
    **为什么需要多路分解？**  
    主机接收到的数据报文负载可能是针对不同的应用程序或协议的。将这些负载定向到适当的应用程序或协议的过程称为多路分解。

---

## TCP Socket Identification / TCP 套接字标识

A TCP socket is identified by a 4-tuple:  
**TCP 套接字由四元组标识：**

1. **Source IP Address**  
    The IP address of the sender.  
    **发送方的 IP 地址。**
    
2. **Source Port Number**  
    The port number of the sender.  
    **发送方的端口号。**
    
3. **Destination IP Address**  
    The IP address of the receiver.  
    **接收方的 IP 地址。**
    
4. **Destination Port Number**  
    The port number of the receiver.  
    **接收方的端口号。**
    

- **Why TCP uses 4-tuple identification?**  
    Because TCP is connection-oriented, segments with the same port numbers can be demultiplexed to different sockets. This allows multiple connections to be established between the same pair of hosts using different ports.  
    **为什么 TCP 使用四元组标识？**  
    因为 TCP 是面向连接的，具有相同端口号的段可以被多路分解到不同的套接字。这允许在相同的主机对之间使用不同的端口建立多个连接。

**UDP:** Uses only the **destination port number** for demultiplexing because it is connectionless.  
    **UDP：** 由于是无连接的，仅使用**目标端口号**进行多路分解。
    
- **TCP:** Uses a **4-tuple** (source IP, source port, destination IP, destination port) for demultiplexing because it is connection-oriented.  
    **TCP：** 由于是面向连接的，使用**四元组**（源 IP、源端口、目标 IP、目标端口）进行多路分解。
    
- **Multiplexing/Demultiplexing:** Occurs at all layers of the network stack, ensuring that data is correctly combined and separated as it moves through the system.  
    **多路复用/多路分解：** 发生在网络堆栈的所有层中，确保数据在系统中移动时能够正确地合并和分离。

---
# Principles of Reliable Data Transfer / 可靠数据传输的原则

Even though the application layer may implement unidirectional data transfer between a sender and a receiver, within the protocol itself, the sender and receiver communicate with each other over a **bi-directional unreliable channel**.  
尽管应用层可能在发送方和接收方之间实现单向数据传输，但在协议内部，发送方和接收方通过**双向不可靠信道**进行通信。

- **Key Challenge:** The sender and receiver do not know the state of each other.  
    **主要挑战：** 发送方和接收方不知道彼此的状态。

To handle this uncertainty, we use **Finite State Machines (FSMs)** to model the behavior of both the sender and the receiver.  
为了解决这种不确定性，我们使用**有限状态机（FSM）**来模拟发送方和接收方的行为。

---

## 1. Underlying Channel Perfectly Reliable / 底层信道完全可靠

In the simplest case, we assume that the underlying channel is perfectly reliable:  
在最简单的情况下，我们假设底层信道是完全可靠的：

- **No bit errors:** No bits are flipped during transmission.  
    **无比特错误：** 在传输过程中没有比特被翻转。
    
- **No packet loss:** All packets are delivered successfully.  
    **无数据包丢失：** 所有数据包都成功交付。

### Separate FSMs for Sender and Receiver / 发送方和接收方的独立 FSM
- **Sender:** Sends data into the underlying channel.  
    **发送方：** 将数据发送到底层信道。
    
- **Receiver:** Reads data from the underlying channel.  
    **接收方：** 从底层信道读取数据。

In this scenario, no additional mechanisms are needed because the channel is assumed to be error-free.  
在这种情况下，不需要额外的机制，因为信道被认为是无错误的。

---

## 2. Channel with Bit Errors / 存在比特错误的信道

In real-world scenarios, the underlying channel may introduce bit errors in packets.  
在现实世界中，底层信道可能会在数据包中引入比特错误。

### Key Mechanisms to Handle Bit Errors / 处理比特错误的关键机制

#### Acknowledgements (ACKs) / 确认机制
- **Definition:** The receiver explicitly tells the sender that a packet was received correctly.  
    **定义：** 接收方明确告知发送方某个数据包已正确接收。
    
- **Purpose:** Ensures that the sender knows which packets have been successfully received.  
    **目的：** 确保发送方知道哪些数据包已成功接收。

#### Negative Acknowledgements (NAKs) / 否定确认机制
- **Definition:** The receiver explicitly tells the sender that a packet had an error.  
    **定义：** 接收方明确告知发送方某个数据包存在错误。
    
- **Purpose:** Allows the sender to retransmit the corrupted packet.  
    **目的：** 允许发送方重新传输损坏的数据包。

#### Sequence Numbers / 序列号
- **Why Use Sequence Numbers?**  
    If the sender receives duplicate ACKs or NAKs, it might retransmit the same packet multiple times. To avoid delivering duplicate packets to the application layer, the sender adds a **sequence number** to each packet.  
    **为什么要使用序列号？**  
    如果发送方收到重复的 ACK 或 NAK，它可能会多次重新传输相同的数据包。为了避免将重复的数据包传递到应用层，发送方为每个数据包添加一个**序列号**。

- **How It Works:**  
    The receiver discards (does not deliver up) duplicate packets based on their sequence numbers.  
    **它是如何工作的？**  
    接收方根据数据包的序列号丢弃（不向上层传递）重复的数据包。

#### Timeout Mechanism / 超时机制
- **Why Use Timeout?**  
    In cases where packets are lost, the sender sets a **timeout** period. If no ACK or NAK is received within this period, the sender retransmits the packet.  
    **为什么要使用超时机制？**  
    在数据包丢失的情况下，发送方设置一个**超时**周期。如果在此期间未收到 ACK 或 NAK，发送方将重新传输数据包。

- **Handling Duplicates:**  
    The receiver must ignore duplicate messages and only process the first instance of each packet.  
    **处理重复消息：**  
    接收方必须忽略重复的消息，并且只处理每个数据包的第一个实例。

---

## 3. Improving Performance: Pipelining / 提高性能：流水线传输

To improve performance, especially in high-latency networks, we can use **pipelining**, which allows the sender to transmit multiple packets without waiting for individual acknowledgments.  
为了提高性能，特别是在高延迟网络中，我们可以使用**流水线传输**，它允许发送方在不等待单独确认的情况下传输多个数据包。

### Key Features of Pipelining / 流水线传输的关键特性

- **Increased Range of Sequence Numbers:**  
    Since multiple packets are "in flight" simultaneously, the range of sequence numbers must be increased to uniquely identify each packet.  
    **增加序列号范围：**  
    由于多个数据包同时“在途”，因此必须增加序列号范围以唯一标识每个数据包。

- **Buffering at Sender and/or Receiver:**  
    Both the sender and receiver may need to buffer packets to handle out-of-order arrivals or retransmissions.  
    **发送方和/或接收方的缓冲：**  
    发送方和接收方可能需要缓冲数据包以处理乱序到达或重传。

---

## 4. Go-Back-N (GBN) Protocol / Go-Back-N 协议

The **Go-Back-N (GBN)** protocol is a sliding window protocol that improves efficiency by allowing multiple packets to be in transit simultaneously.  
**Go-Back-N (GBN)** 协议是一种滑动窗口协议，通过允许多个数据包同时传输来提高效率。

### Key Features of GBN / GBN 的关键特性

- **Cumulative ACKs:**  
    The receiver always sends an ACK for the highest in-order sequence number it has received so far.  
    **累积确认：**  
    接收方始终为其迄今为止接收到的最高顺序序列号发送 ACK。

- **Out-of-Order Packets:**  
    When the receiver gets an out-of-order packet, it can either discard it or buffer it (an implementation decision). It then re-ACKs the packet with the highest in-order sequence number.  
    **乱序数据包：**  
    当接收方收到乱序数据包时，它可以丢弃该数据包或将该数据包缓冲（这是一个实现决策）。然后，它会重新发送具有最高顺序序列号的数据包的 ACK。

- **Timeout and Retransmission:**  
    If the sender does not receive an ACK for a packet within the timeout period, it retransmits all packets starting from the first unacknowledged packet.  
    **超时与重传：**  
    如果发送方在超时时间内未收到某个数据包的 ACK，则它会从第一个未确认的数据包开始重新传输所有数据包。

---

## 5. Selective Repeat Protocol / 选择性重传协议

The **Selective Repeat (SR)** protocol is another sliding window protocol that improves upon GBN by only retransmitting lost or corrupted packets, rather than retransmitting all packets from the first unacknowledged one.  
**选择性重传（SR）** 协议是另一种滑动窗口协议，它通过仅重新传输丢失或损坏的数据包（而不是从第一个未确认的数据包开始重新传输所有数据包）来改进 GBN。

### Key Features of SR / SR 的关键特性

- **Individual Acknowledgments:**  
    The receiver individually acknowledges all correctly received packets.  
    **单独确认：**  
    接收方单独确认所有正确接收的数据包。

- **Buffering at Receiver:**  
    The receiver buffers out-of-order packets and only requests retransmission of the lost packets.  
    **接收方缓冲：**  
    接收方缓冲乱序数据包，并且仅请求重新传输丢失的数据包。

- **Timeout and Retransmission:**  
    The sender times out and retransmits only the unacknowledged packets, rather than retransmitting all packets.  
    **超时与重传：**  
    发送方超时并仅重新传输未确认的数据包，而不是重新传输所有数据包。

---

- **Underlying Channel Assumptions:**  
    - Perfectly reliable channel: No bit errors, no packet loss.  
        **完全可靠的信道：** 无比特错误，无数据包丢失。
    - Channel with bit errors: Use ACKs, NAKs, sequence numbers, and timeouts to ensure reliability.  
        **存在比特错误的信道：** 使用 ACK、NAK、序列号和超时机制来确保可靠性。

- **Pipelining:**  
    - Allows multiple packets to be in transit simultaneously, improving performance.  
        **流水线传输：** 允许多个数据包同时传输，从而提高性能。
    - Requires increased sequence number range and buffering at sender/receiver.  
        **要求：** 增加序列号范围，并在发送方/接收方进行缓冲。

- **Go-Back-N (GBN):**  
    - Retransmits all packets from the first unacknowledged packet when a timeout occurs.  
        **Go-Back-N：** 当发生超时时，重新传输从第一个未确认数据包开始的所有数据包。

- **Selective Repeat (SR):**  
    - Retransmits only the lost or corrupted packets, improving efficiency over GBN.  
        **选择性重传：** 仅重新传输丢失或损坏的数据包，比 GBN 更高效。


---
# TCP Overview

### Connection-Oriented Transport: TCP

**Point-to-Point**  
TCP is a point-to-point protocol, meaning it establishes a connection between one sender and one receiver. Each connection is independent, ensuring data flows from the sender to the receiver.  
TCP是一个点对点协议，表示一个发送者和一个接收者之间的连接。每个连接都是独立的，确保数据从发送方传输到接收方。

**Reliable, In-Order Byte Stream**  
TCP ensures reliable data transmission and guarantees that data reaches the receiver in the correct order. Notably, TCP does not distinguish between “messages,” treating the data as a continuous byte stream that both the sender and receiver handle.  
TCP保证数据的可靠传输，并确保数据按照发送顺序到达接收方。值得注意的是，TCP并不区分“消息”，而是将数据视为一个连续的字节流，发送方和接收方都会处理这一字节流。

**Full Duplex Data**  
TCP allows data to flow in both directions on the same connection, meaning the sender and receiver can send and receive data simultaneously.  
TCP允许数据在同一个连接上双向流动，这意味着发送方和接收方可以同时进行数据的发送和接收。

**MSS: Maximum Segment Size**  
MSS defines the maximum amount of data that can be sent in a single TCP segment. It helps avoid fragmentation and ensures efficient data transfer.  
MSS定义了在单个TCP段中可以发送的最大数据量。它帮助避免分段并确保高效的数据传输。

---

### Cumulative Acknowledgements

TCP uses cumulative acknowledgements, meaning the receiver confirms the receipt of all data up to a certain sequence number. Even if some data is lost, the receiver can send repeated acknowledgements for the last successfully received sequence number, informing the sender to retransmit the missing data.  
TCP使用累计确认机制，意味着接收方确认已接收的所有数据，直到某个特定的序列号。即使某些数据丢失，接收方仍可以发送重复的确认，指示发送方重新传输丢失的数据。

---

### TCP Timeout and Retransmission

**Setting TCP Timeout**  
TCP calculates the timeout interval based on the estimated round-trip time (RTT) and the deviation of RTT. If the sender does not receive an acknowledgment within the timeout period, it retransmits the segment.  
**设置TCP超时**  
TCP根据估算的往返时间（RTT）和RTT的偏差计算超时间隔。如果发送方在超时时间内没有收到确认，它会重新传输数据段。

- **Estimate RTT**:
    
    estimateRTT=(1−α)∗estimatedRTT+α∗sampleRTT\text{estimateRTT} = (1 - \alpha) * \text{estimatedRTT} + \alpha * \text{sampleRTT}estimateRTT=(1−α)∗estimatedRTT+α∗sampleRTT
    
    The parameter α\alphaα is typically set to 0.125.  
    **估算RTT**:
    
    estimateRTT=(1−α)∗estimatedRTT+α∗sampleRTT\text{estimateRTT} = (1 - \alpha) * \text{estimatedRTT} + \alpha * \text{sampleRTT}estimateRTT=(1−α)∗estimatedRTT+α∗sampleRTT
    
    参数α\alphaα通常设置为0.125。
    
- **Timeout Interval**:
    
    TimeoutInterval=estimateRTT+4∗DevRTT\text{TimeoutInterval} = \text{estimateRTT} + 4 * \text{DevRTT}TimeoutInterval=estimateRTT+4∗DevRTT
    
    **超时间隔**:
    
    TimeoutInterval=estimateRTT+4∗DevRTT
**TCP Sender Behavior**  
The TCP sender divides the application data into segments, each with a sequence number. The sender uses a timer to monitor unacknowledged segments. If a segment's acknowledgment does not arrive within the timeout period, the sender retransmits the segment.  
**TCP发送者行为**  
TCP发送者将应用层数据划分成多个数据段，每个数据段都有一个序列号。发送方使用计时器来监控未确认的数据段。如果某个数据段的确认在超时期间内没有到达，发送方会重新传输该数据段。

---

### TCP Flow Control

TCP flow control ensures that the sender does not overwhelm the receiver's buffer by sending data too quickly. The receiver tells the sender the size of the available buffer in the `rwnd` field of the TCP header, which helps control the flow of data.  
TCP流量控制确保发送方不会因发送数据过快而超出接收方缓冲区的容量。接收方会在TCP头部的`rwnd`字段中告诉发送方可用的缓冲区大小，从而帮助控制数据流。

---

### TCP Connection Management

Before exchanging data, TCP establishes a connection through a process called the three-way handshake. The three-way handshake helps both the sender and receiver agree on the starting sequence numbers and other connection parameters.  
在交换数据之前，TCP通过三次握手来建立连接。三次握手确保发送方和接收方能够就初始序列号以及其他连接参数达成一致。

**Three-Way Handshake**

1. **SYN**: The client sends a SYN message to the server, requesting a connection and providing an initial sequence number.
2. **SYN-ACK**: The server responds with a SYN-ACK, confirming the connection and providing its own initial sequence number.
3. **ACK**: The client sends an ACK message to confirm the server's response, and the connection is established.  
    **三次握手**
4. **SYN**: 客户端向服务器发送SYN消息，请求建立连接，并提供初始序列号。
5. **SYN-ACK**: 服务器回应一个SYN-ACK，确认连接并提供自己的初始序列号。
6. **ACK**: 客户端发送ACK消息确认服务器的响应，连接建立成功。

---

### Sequence Numbers and Acknowledgements

**Sequence Number**  
The sequence number identifies the first byte of data in a segment. TCP uses sequence numbers to ensure that data is delivered in order and to track the data that has been successfully received.  
**序列号**  
序列号标识数据段中第一个字节的位置。TCP使用序列号确保数据按顺序传输，并追踪已成功接收的数据。

**Acknowledgement Number**  
The acknowledgment number indicates the sequence number of the next byte the receiver expects to receive. For example, if the receiver has received up to byte 92, it will send an ACK with the acknowledgment number 93, indicating that it expects the next byte to be 93.  
**确认号**  
确认号表示接收方期望接收的下一个字节的序列号。例如，如果接收方已经收到92之前的所有字节，它将发送ACK 93，表示它期望接收下一个字节为93。

---

### Figures

**TCP Three-Way Handshake**  
![TCP Three-Way Handshake](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/20250222182215.png)  
This figure illustrates the three-way handshake process used to establish a TCP connection.  
这张图展示了用于建立TCP连接的三次握手过程。

**TCP Segment Structure**  
![TCP Segment Structure](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/cd1e4d87-6786-4aa7-9fe0-79615c942efe.png)  
This figure shows the structure of a TCP segment, including important fields such as the sequence number, acknowledgment number, and window size.  
这张图展示了TCP报文段的结构，包括序列号、确认号、窗口大小等重要字段。

# TCP Congestion Control: AIMD, TCP CUBIC, and ECN

## TCP Congestion Control Overview (TCP拥塞控制概述)

TCP congestion control is a critical mechanism to ensure the stability and efficiency of network communications. It prevents network congestion by dynamically adjusting the sending rate of data based on network conditions. The primary goal is to optimize throughput while minimizing delay and packet loss.

TCP拥塞控制是确保网络通信稳定性和效率的关键机制。它通过根据网络状况动态调整数据发送速率来防止网络拥塞。其主要目标是在最小化延迟和丢包的同时优化吞吐量。

---

## Additive Increase Multiplicative Decrease (AIMD) (加性增乘性减)

### Key Principles (关键原则)

- **Probing for Bandwidth** : Senders gradually increase their sending rate until packet loss occurs, which signals congestion.
- **Rate Adjustment** :
    - On detecting packet loss via **triple duplicate ACKs** (TCP Reno), the sending rate is halved.
    - On detecting packet loss via **timeout** , the sending rate is reduced to **1 Maximum Segment Size (MSS)** .
- **Stability** : AIMD ensures that congested flows stabilize across the network by controlling the length of in-flight sequences and available-but-unused sequences.

逐步增加发送速率，直到发生丢包（表明拥塞）。当检测到丢包时：

- 如果通过**三次重复ACK** （TCP Reno）检测到丢包，则发送速率减半。
- 如果通过**超时** 检测到丢包，则发送速率降至**1个最大段大小（MSS）** 。
- **稳定性** ：AIMD通过控制正在传输的序列长度和可用但未使用的序列长度，确保拥塞流在网络范围内稳定。

### Slow Start and Transition to Linear Growth (慢启动与线性增长的过渡)

- Initially, the sending rate starts slow but ramps up exponentially during the **slow start phase** . The congestion window (`cwnd`) doubles every round-trip time (RTT).
- The exponential growth switches to **linear growth** when `cwnd` reaches half of its value before the last timeout. This transition ensures that the sender avoids overwhelming the network while still probing for available bandwidth.

初始发送速率较慢，但在**慢启动阶段** 呈指数增长。拥塞窗口（`cwnd`）每轮往返时间（RTT）翻倍。当`cwnd`达到上次超时前值的一半时，指数增长切换为**线性增长** 。这种过渡确保发送方在探测可用带宽的同时避免对网络造成过载。

---

## TCP CUBIC: A Modern Approach (TCP CUBIC：一种现代方法)

### Key Features (关键特性)

- After a packet loss event, TCP CUBIC reduces the sending rate/window by half. However, it ramps up to the previous maximum window size (`Wmax`, the sending rate at which congestion loss was detected) faster than traditional AIMD.
- As the window approaches `Wmax`, the growth slows down to avoid triggering further congestion.
- **Window Growth Function** : The window size (`W`) increases as a cubic function of the time elapsed since the last congestion event. Specifically:
    - Larger increases occur when farther from the target point `K` (the time when the window will reach `Wmax`).
    - Smaller increases occur when closer to `K`.

在丢包事件后，TCP CUBIC将发送速率/窗口减半。然而，它比传统的AIMD更快地恢复到之前的最大窗口大小（`Wmax`，即发生拥塞丢包时的发送速率）。当窗口接近`Wmax`时，增长速度减缓以避免触发进一步的拥塞。

- **窗口增长函数** ：窗口大小（`W`）随着自上次拥塞事件以来的时间呈立方函数增长。具体而言：
    - 当距离目标点`K`（窗口达到`Wmax`的时间）较远时，增长幅度较大。
    - 当接近`K`时，增长幅度较小。

![](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/20250222203120.png)
### Bottleneck Link Optimization (瓶颈链路优化)

- TCP CUBIC aims to keep the sender-to-receiver pipeline "just full enough, but no fuller." This means:
    - Keeping the bottleneck link busy transmitting data.
    - Avoiding excessive buffering, which can lead to high delays.

TCP CUBIC的目标是使发送方到接收方的管道“足够满，但不过满”。这意味着：

- 保持瓶颈链路忙于传输数据。
- 避免过多的缓冲，这可能导致高延迟。

---

## Explicit Congestion Notification (ECN) (显式拥塞通知)

### How ECN Works (ECN的工作原理)

- ECN leverages two bits in the IP header, marked by network routers to indicate congestion.
- When a router detects congestion, it sets the ECN bits in the packet header.
- The destination receives the packet, recognizes the congestion indication, and sets the **ECE bit** (Explicit Congestion Experienced) on the ACK segment to notify the sender of congestion.
- The sender responds by reducing its sending rate to alleviate congestion.

ECN利用IP头部中的两位，由网络路由器标记以指示拥塞。当路由器检测到拥塞时，它会在数据包头部设置ECN位。目的地接收到数据包，识别到拥塞指示，并在ACK段中设置**ECE位** （显式拥塞体验）以通知发送方拥塞。发送方通过降低发送速率来缓解拥塞。

### Benefits of ECN (ECN的优势)

- **Reduced Packet Loss** : By signaling congestion before packets are dropped, ECN helps reduce packet loss.
    
- **Improved Throughput** : ECN allows senders to adjust their rates more gracefully, improving overall throughput.
    
- **Lower Latency** : By avoiding bufferbloat (excessive queuing delays), ECN helps maintain low latency.
    
- **减少丢包** ：通过在丢包之前发出拥塞信号，ECN有助于减少丢包。
    
- **提高吞吐量** ：ECN允许发送方更平稳地调整速率，从而提高整体吞吐量。
    
- **降低延迟** ：通过避免缓冲区膨胀（过度排队延迟），ECN有助于保持低延迟。
    

### Fairness in Shared Bottleneck Links (共享瓶颈链路中的公平性)

- If `K` TCP sessions share the same bottleneck link with bandwidth `R`, each session should ideally achieve an average rate of `R/K`. ECN assists in achieving this fairness by providing timely congestion feedback to all senders.

如果`K`个TCP会话共享带宽为`R`的同一瓶颈链路，则每个会话的理想平均速率应为`R/K`。ECN通过向所有发送方提供及时的拥塞反馈，帮助实现这种公平性。

---


## Router Architecture and Functions (路由器架构与功能)

A router consists of two main components: the **routing processor** (control plane) and the **high-speed switching fabric** (data plane). The control plane handles routing management and protocol operations, while the data plane performs packet forwarding at hardware speeds, typically in nanoseconds.

路由器由两个主要组件组成：**路由处理器** （控制平面）和**高速交换结构** （数据平面）。控制平面负责路由管理和协议操作，而数据平面以硬件速度执行数据包转发，通常在纳秒级完成。

### Input Port Functions (输入端口功能)

1. **Physical Layer** : Handles bit-level reception and line termination.
    - 物理层：处理比特级接收和线路终止。
2. **Link Layer** : Implements link-layer protocols (e.g., Ethernet) for receiving frames.
    - 链路层：实现链路层协议（如以太网）以接收帧。
3. **Network Layer** : The most critical function is the lookup and forwarding process, which determines the appropriate output port based on the destination IP address. This is often referred to as "match plus action."
    - 网络层：最关键的功能是查找和转发过程，根据目标IP地址确定适当的输出端口。这通常被称为“匹配加动作”。

### Destination-Based Forwarding (基于目标的转发)

- Traditional forwarding is based solely on the destination IP address. A range of destination addresses is mapped to a specific link interface.
    - 传统转发仅基于目标IP地址。一系列目标地址被映射到特定的链路接口。
- **Longest Prefix Matching** : For a 32-bit IP address, the router matches the longest prefix in its forwarding table. All leftmost bits of the IP address must match the ones and zeros in the prefix.
    - **最长前缀匹配** ：对于32位IP地址，路由器在其转发表中匹配最长前缀。IP地址的所有左起位必须与前缀中的1和0匹配。
- This operation is performed in hardware using **Ternary Content-Addressable Memory (TCAM)** , which retrieves the matching entry in a single clock cycle, regardless of table size.
    - 此操作通过硬件使用**三态内容可寻址存储器（TCAM）**完成，它可以在一个时钟周期内检索匹配项，与表大小无关。

### Switching Fabric (交换结构)

The switching fabric transfers packets from input links to the appropriate output links, determined by the longest prefix match. The **switching rate** is the most critical metric, representing the rate at which packets can be transferred from inputs to outputs.

交换结构将数据包从输入链路传输到适当的输出链路，由最长前缀匹配决定。**交换速率** 是最关键的指标，表示数据包从输入到输出的传输速率。

### Generalized Forwarding (广义转发)

Modern routers support generalized forwarding, which allows forwarding decisions based on any set of header field values. This includes:

- Matching over multiple fields (link layer, network layer, transport layer).
- Performing local actions such as dropping, forwarding, modifying, or sending matched packets to a controller.

现代路由器支持广义转发，允许基于任何一组头部字段值进行转发决策。这包括：

- 在多个字段（链路层、网络层、传输层）上进行匹配。
- 执行本地操作，例如丢弃、转发、修改或将匹配的数据包发送到控制器。

---

## Queuing and Buffering (排队与缓冲)

- **Input Port Queuing** : Occurs when packets arrive faster than the switching fabric can process them.
    - **输入端口排队** ：当数据包到达速度超过交换结构的处理能力时发生。
- **Output Port Queuing** : Occurs when packets are transmitted slower than the link transmission rate.
    - **输出端口排队** ：当数据包传输速度低于链路传输速率时发生。
- Buffering is required when datagrams arrive from the switching fabric faster than the link transmission rate. However:
    - Large buffers lead to higher delays and larger Round-Trip Times (RTT).
    - Small buffers result in packet loss.
    - 缓冲在数据包从交换结构到达速度快于链路传输速率时是必需的。然而：
        - 大缓冲区会导致更高的延迟和更大的往返时间（RTT）。
        - 小缓冲区会导致数据包丢失。

### Scheduling Discipline (调度规则)

The scheduling discipline determines how queued datagrams are selected for transmission. Priority scheduling can affect performance and raise questions about network neutrality.

调度规则决定了如何选择排队的数据包进行传输。优先级调度会影响性能，并引发关于网络中立性的讨论。

---

## IP Protocol Fundamentals (IP协议基础)

### IP Datagram Format (IP数据报格式)

The IP datagram consists of a header and payload. The header contains fields such as the source and destination IP addresses, version, header length, and more.

IP数据报由头部和有效载荷组成。头部包含源和目标IP地址、版本、头部长度等字段。

![](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/20250223004057.png)

### IP Addressing (IP地址)

- An IP address is a 32-bit identifier associated with each host or router interface.
    - IP地址是一个与每个主机或路由器接口关联的32位标识符。
- A **subnet** is a group of device interfaces that can physically reach each other without passing through an intervening router.
    - **子网** 是一组无需经过中间路由器即可物理到达彼此的设备接口。
- IP addresses are divided into a **network part** and a **host part** . The network part identifies the subnet, while the host part identifies individual devices within the subnet.
    - IP地址分为**网络部分** 和**主机部分** 。网络部分标识子网，而主机部分标识子网内的单个设备。

### CIDR and DHCP (无类别域间路由与动态主机配置协议)

- **CIDR (Classless Inter-Domain Routing)** : Allows flexible allocation of IP addresses by using variable-length prefixes.
    - **CIDR（无类别域间路由）** ：通过使用可变长度前缀，允许灵活分配IP地址。
- **DHCP (Dynamic Host Configuration Protocol)** :
    - Enables hosts to renew their IP address leases.
    - Supports address reuse and mobile users who join or leave the network.
    - DHCP服务器通常与路由器共置，服务于路由器连接的所有子网。
    - 动态主机配置协议（DHCP）：
        - 允许主机续订其IP地址租约。
        - 支持地址重用以及加入或离开网络的移动用户。
        - DHCP服务器通常与路由器共置，服务于路由器连接的所有子网。

### NAT (Network Address Translation) (网络地址转换)

- NAT allows all devices in a local network to share a single IPv4 address when communicating with the outside world. Outgoing datagrams have their source IP replaced with the NAT IP, while incoming datagrams have the NAT IP replaced with the original source IP stored in the NAT translation table.
    - NAT允许本地网络中的所有设备在与外部通信时共享一个IPv4地址。传出数据包的源IP被替换为NAT IP，而传入数据包的NAT IP被替换为存储在NAT转换表中的原始源IP。

---

## IPv6 Fundamentals (IPv6基础)

### Motivation for IPv6 (IPv6的动机)

- Faster processing and forwarding due to a fixed 40-byte header.
    - 固定的40字节头部实现更快的处理和转发。
- Enables differentiated network-layer treatment of flows.
    - 支持对流的差异化网络层处理。

### IPv6 Datagram Format (IPv6数据报格式)

![](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/5c2d4f92-9dfe-469d-91dd-5b96d0f2e27f.png)

### Transition from IPv4 to IPv6 (从IPv4到IPv6的过渡)

- **Tunneling** : IPv6 datagrams are encapsulated as payloads within IPv4 datagrams during the transition period.
    - **隧道技术** ：在过渡期间，IPv6数据报被封装为IPv4数据报的有效载荷。

---

## Match Plus Action Paradigm (匹配加动作范式)

- Modern networking devices use the "match plus action" paradigm, where packets are matched against multiple fields (link layer, network layer, transport layer) and actions such as dropping, forwarding, modifying, or sending to a controller are performed.
    - 现代网络设备使用“匹配加动作”范式，其中数据包根据多个字段（链路层、网络层、传输层）进行匹配，并执行丢弃、转发、修改或发送到控制器等操作。

---

## Middlebox Functions (中间盒功能)

Middleboxes perform various functions such as NAT, firewalls, Intrusion Detection Systems (IDS), load balancers, caches, and application-specific processing.

中间盒执行各种功能，例如NAT、防火墙、入侵检测系统（IDS）、负载均衡器、缓存和特定应用处理。

![](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/02ed7eefb423c5d7a3dc599debdf8474.png)

---

## The End-to-End Argument (端到端原则)

Some network functionality can be implemented either within the network itself or at the network edge. The end-to-end argument suggests that certain functions, such as reliability and security, are better handled at the endpoints rather than within the network core.

某些网络功能可以在网络内部或网络边缘实现。端到端原则认为，某些功能（如可靠性和安全性）最好由端点而非网络核心来处理。

---

# Routing Algorithms and Link Layer Services

## Routing Algorithm Classification (路由算法分类)

Routing algorithms can be broadly classified into two categories: **Link-State (LS)** and **Distance Vector (DV)** . These algorithms differ in how they gather and process network topology information to compute the shortest paths.

路由算法大致可分为两类：**链路状态（LS）**和** 距离矢量（DV）** 。这些算法在收集和处理网络拓扑信息以计算最短路径的方式上有所不同。

![](https://cdn.jsdelivr.net/gh/kachofugetsu09/Picture-bed@main/img/9180f3af-80eb-4ed1-ac06-7d63d6ce0b7a.png)

---

## Dijkstra's Link-State Routing Algorithm (Dijkstra的链路状态路由算法)

### Key Characteristics (关键特性)

- **Centralized Knowledge** : The network topology and link costs are known to all nodes, typically achieved through **link-state broadcast** .
    - **集中式知识** ：网络拓扑和链路成本为所有节点所知，通常通过**链路状态广播** 实现。
- **Uniform Information** : All nodes have the same information about the network.
    - **统一信息** ：所有节点对网络的信息相同。
- **Least-Cost Paths** : Computes the least-cost paths from one node to all other nodes, generating a forwarding table for that node.
    - **最低成本路径** ：计算从一个节点到所有其他节点的最低成本路径，生成该节点的转发表。

### Algorithm Process (算法过程)

- **Iterative Computation** : After `k` iterations, the algorithm knows the least-cost path to `k` destinations.
    - **迭代计算** ：经过`k`次迭代后，算法知道到达`k`个目的地的最低成本路径。
- **Complexity** : Each of the `n` iterations requires checking all nodes not yet included in the set `N`. The naive implementation has a time complexity of `O(n^2)`, but more efficient implementations achieve `O(n log n)`.
    - **复杂度** ：每次迭代需要检查尚未包含在集合`N`中的所有节点。朴素实现的时间复杂度为`O(n^2)`，但更高效的实现可达到`O(n log n)`。

### Message Complexity (消息复杂度)

- Each router broadcasts its link-state information to all other routers in the network.
    - 每个路由器将其链路状态信息广播到网络中的所有其他路由器。
- Efficient broadcast algorithms require `O(n)` link crossings to disseminate a message from one source, resulting in an overall message complexity of `O(n^2)`.
    - 高效的广播算法需要`O(n)`次链路交叉来传播来自一个源的消息，整体消息复杂度为`O(n^2)`。

### Potential Issues (潜在问题)

- When link costs depend on traffic volume, route oscillations may occur, leading to instability in routing decisions.
    - 当链路成本依赖于流量时，可能会发生路由振荡，导致路由决策不稳定。

---

## Distance Vector Algorithm (距离矢量算法)

### Key Characteristics (关键特性)

- Based on the **Bellman-Ford equation** (dynamic programming), the algorithm computes the shortest paths by iteratively updating distance vectors.
    - 基于**贝尔曼-福特方程** （动态规划），该算法通过迭代更新距离矢量来计算最短路径。
- Each node periodically sends its distance vector estimate to its neighbors.
    - 每个节点定期向其邻居发送其距离矢量估计。

### Algorithm Process (算法过程)

1. **Wait for Changes** : A node waits for changes in local link costs or messages from neighbors.
    - **等待变化** ：节点等待本地链路成本的变化或来自邻居的消息。
2. **Recompute Distance Vectors** : Using the Bellman-Ford equation, the node updates its own distance vector based on received estimates from neighbors.
    - **重新计算距离矢量** ：使用贝尔曼-福特方程，节点根据从邻居接收到的估计值更新自己的距离矢量。
3. **Propagate Updates** : If the node's distance vector to any destination changes, it sends the updated vector to its neighbors; otherwise, no action is taken.
    - **传播更新** ：如果节点到任何目的地的距离矢量发生变化，则将更新后的矢量发送给邻居；否则不采取任何操作。

### Message Complexity (消息复杂度)

- **LS vs. DV** :
    - In LS, each router broadcasts link-state information to all other routers, resulting in `O(n^2)` messages.
    - In DV, messages are exchanged only between neighbors, but convergence time varies significantly.
        - 在LS中，每个路由器将链路状态信息广播到所有其他路由器，导致`O(n^2)`条消息。
        - 在DV中，消息仅在邻居之间交换，但收敛时间差异显著。

### Speed of Convergence (收敛速度)

- **LS** : The algorithm runs in `O(n^2)` time and exchanges `O(n^2)` messages. However, route oscillations may occur.
    - **LS** ：算法运行时间为`O(n^2)`，交换`O(n^2)`条消息。然而，可能会发生路由振荡。
- **DV** : Convergence time varies, and issues like **routing loops** and the **count-to-infinity problem** may arise.
    - **DV** ：收敛时间不同，并可能出现**路由环路** 和**计数到无穷问题** 等。

---

## Making Routing Scalable (使路由具有可扩展性)

### Internet Approach to Scalable Routing (互联网可扩展路由方法)

#### Intra-AS Routing (域内路由)

- Routing among routers within the same Autonomous System (AS).
    - 在同一自治系统（AS）内的路由器之间进行路由。
- All routers in an AS must run the same intra-domain protocol, while routers in different ASes can use different protocols.
    - 一个AS中的所有路由器必须运行相同的域内协议，而不同AS中的路由器可以使用不同的协议。
- **Gateway Routers** : Located at the "edge" of their AS, these routers have links to routers in other ASes.
    - **网关路由器** ：位于其AS的“边缘”，这些路由器与其他AS中的路由器有连接。

#### Inter-AS Routing (域间路由)

- Routing among different ASes.
    - 在不同AS之间进行路由。
- Gateways perform inter-domain routing using protocols like **BGP** .
    - 网关使用如**BGP** 等协议执行域间路由。

---

## OSPF (Open Shortest Path First) Routing (开放最短路径优先路由)

### Key Features (关键特性)

- Publicly available and based on classic link-state principles.
    - 公开可用，基于经典的链路状态原则。
- Each router floods OSPF link-state advertisements to all other routers in the AS.
    - 每个路由器将OSPF链路状态广告洪泛到AS中的所有其他路由器。
- Supports multiple link cost metrics, such as bandwidth and delay.
    - 支持多种链路成本指标，例如带宽和延迟。
- Uses **Dijkstra's algorithm** to compute forwarding tables.
    - 使用**Dijkstra算法** 计算转发表。
- All OSPF messages are authenticated for security.
    - 所有OSPF消息都经过身份验证以确保安全。

### Hierarchical OSPF (分层OSPF)

- **Local Area Backbone** :
    - Link-state advertisements are flooded only within an area or backbone.
    - 每个节点拥有详细的区域拓扑信息，但只知道到达其他目的地的方向。
    - 链路状态广告仅在区域内或骨干网内洪泛。

---

## Internet Inter-AS Routing: BGP (边界网关协议)

### Key Features (关键特性)

- **De Facto Standard** : BGP is the de facto inter-domain routing protocol.
    - **事实标准** ：BGP是事实上的域间路由协议。
- Allows subnets to advertise their existence and the destinations they can reach.
    - 允许子网宣传其存在以及它们可以到达的目的地。
- Provides mechanisms for:
    - Obtaining destination network reachability information from neighboring ASes.
    - Determining routes to other networks based on reachability and policy.
    - Propagating reachability information to all internal routers within the AS.
    - 提供机制：
        - 从相邻AS获取目标网络可达性信息。
        - 根据可达性和策略确定通往其他网络的路由。
        - 将可达性信息传播到AS内的所有内部路由器。

### Gateway Routers (网关路由器)

- Run both **eBGP** (external BGP) for inter-AS communication and **iBGP** (internal BGP) for intra-AS communication.
    - 运行**eBGP** （外部BGP）用于AS间通信，运行**iBGP** （内部BGP）用于AS内通信。

### Path Vector Protocol (路径矢量协议)

- Advertises paths to different destination network prefixes.
    - 宣传通往不同目标网络前缀的路径。
- Messages are exchanged between peers over TCP connections.
    - 消息通过TCP连接在对等体之间交换。

### BGP Attributes (BGP属性)

- **AS-PATH** : Lists the ASes through which the prefix advertisement has passed.
    - **AS-PATH** ：列出前缀广告经过的AS。
- **NEXT-HOP** : Indicates the specific internal-AS router to the next-hop AS.
    - **NEXT-HOP** ：指示通往下一跳AS的特定内部AS路由器。

---

## Policy-Based Routing (基于策略的路由)

- Routers apply policies to accept or reject advertised paths.
    - 路由器应用策略接受或拒绝宣传的路径。
- ISPs often prefer to route traffic only to/from their customer networks.
    - ISP通常倾向于仅路由与其客户网络之间的流量。

### Hot Potato Routing (热土豆路由)

- Chooses the local gateway with the least intra-domain cost, ignoring inter-domain costs.
    - 选择域内成本最低的本地网关，忽略域间成本。

---

## ICMP (Internet Control Message Protocol) (互联网控制消息协议)

### Key Functions (关键功能)

- Used by hosts and routers to communicate network-level information.
    - 主机和路由器用于传递网络级信息。
- **Error Reporting** : Reports errors such as unreachable host, network, port, or protocol.
    - **错误报告** ：报告不可达主机、网络、端口或协议等错误。
- **Echo Request/Reply** : Used by tools like `ping`.
    - **回显请求/回复** ：被`ping`等工具使用。

### Implementation Details (实现细节)

- ICMP messages are carried in IP datagrams with protocol number `1`.
    - ICMP消息封装在IP数据报中，协议号为`1`。
- Each ICMP message includes a type, code, and the first 8 bytes of the IP datagram causing the error.
    - 每个ICMP消息包括类型、代码以及导致错误的IP数据报的前8字节。

---

## Link Layer Services (链路层服务)

### Principles Behind Link Layer Services (链路层服务的原则)

- **Error Detection and Correction** : Detects and corrects bit errors caused by signal attenuation or noise.
    - **错误检测与纠正** ：检测并纠正因信号衰减或噪声引起的比特错误。
- **Sharing a Broadcast Channel** : Implements multiple access protocols to manage simultaneous transmissions.
    - **共享广播信道** ：实现多路访问协议以管理同时传输。
- **Link Layer Addressing** : Uses MAC addresses to identify source and destination devices.
    - **链路层寻址** ：使用MAC地址标识源和目标设备。

### Frame Encapsulation (帧封装)

- Encapsulates datagrams into frames by adding headers and trailers.
    - 通过添加头部和尾部将数据报封装成帧。
- Manages channel access if the medium is shared.
    - 如果介质是共享的，则管理信道访问。

### Flow Control and Error Handling (流量控制与错误处理)

- **Flow Control** : Paces data transfer between adjacent nodes.
    - **流量控制** ：调节相邻节点之间的数据传输速率。
- **Error Detection** : Detects errors and signals retransmission or drops frames.
    - **错误检测** ：检测错误并发出重传信号或丢弃帧。
- **Error Correction** : Corrects bit errors without requiring retransmission.
    - **错误纠正** ：无需重传即可纠正比特错误。

---

## Multiple Access Protocols (多路访问协议)

### Types of Links (链路类型)

- **Point-to-Point** : Direct connection between two nodes.
    - **点对点** ：两个节点之间的直接连接。
- **Broadcast** : Shared medium where multiple nodes can transmit simultaneously.
    - **广播** ：多个节点可以同时传输的共享介质。

### Channel Partitioning Protocols (信道划分协议)

- **TDMA (Time Division Multiple Access)** :
    - Access to the channel occurs in rounds, with each station assigned a fixed-length slot per round.
    - **TDMA（时分多址）** ：
        - 信道访问按轮次进行，每轮为每个站点分配固定长度的时隙。
- **FDMA (Frequency Division Multiple Access)** :
    - The channel spectrum is divided into frequency bands, with each station assigned a fixed band.
    - **FDMA（频分多址）** ：
        - 信道频谱被划分为频率带，每个站点分配一个固定带宽。

### CSMA (Carrier Sense Multiple Access) (载波侦听多路访问)

- **Simple CSMA** : Listens before transmitting.
    - **简单CSMA** ：在传输前监听。
- **CSMA with Collision Detection** : Detects collisions early and aborts transmissions to reduce channel wastage.
    - **带冲突检测的CSMA** ：早期检测冲突并中止传输以减少信道浪费。

### Ethernet CSMA Algorithm (以太网CSMA算法)

- If another transmission is detected during sending, the sender aborts and sends a jam signal.
    - 如果在发送过程中检测到另一个传输，发送方中止并发送阻塞信号。
- After aborting, the sender enters binary backoff, waiting for a random interval before retrying.
    - 中止后，发送方进入二进制退避，随机等待一段时间后重试。

---

## Taking Turns Protocols (轮流协议)

### Polling (轮询)

- A centralized controller uses polling messages to invite client nodes to transmit in turn.
    - 集中式控制器使用轮询消息邀请客户端节点轮流传输。

### Token Passing (令牌传递)

- A control token is explicitly passed from one node to the next sequentially.
    - 控制令牌依次显式传递给下一个节点。
- Nodes transmit only while holding the token.
    - 节点仅在持有令牌时传输。



