# 诡异的 DROP 死锁

在了解故事背景之前要先介绍几个东西。

## DDL、DCL、DML

### DDL（Data Definition Language）
**DDL** 是定义或者修改数据结构的语句。例如：
- `CREATE TABLE`
- `ALTER TABLE`
- `DROP TABLE`

### DCL（Data Control Language）
**DCL** 是控制数据访问权限和事务的语句。例如：
- `GRANT`
- `REVOKE`
- `COMMIT`
- `ROLLBACK`

### DML（Data Manipulation Language）
**DML** 是操作数据的语句。例如：
- `INSERT`
- `UPDATE`
- `DELETE`

## MDL 锁的诞生

因为 MySQL 本身想尽量榨干资源，所以它肯定需要并发，需要锁控制。它内部的锁远远不止行锁、表锁这样的，还有各种各样的锁。其中，有一种锁叫做 **MDL锁**（Metadata Lock），它是针对于 DDL 这种表修改语句的。

MySQL 早期版本的一个著名 bug：如果在查询一个表的过程中，即使是 RR 级别，如果另一个会话当中删除了这个表，那么这两次查询结果就不一致了，不满足可重复读的标准。

MDL 应运而生。你可以理解为在 DDL 语句执行前，先获取 MDL 锁，这样其他会话就不能修改表结构，从而避免了上述 bug。但是今天我们要说的 bug 也是因此诞生的。

## gh-ost

**gh-ost** 是一个在线的表修改工具，它会通过复制、重命名的方式提供在线修改表结构的能力。

### 主要流程：

1. **创建一个临时的幽灵表**
2. **数据复制阶段**
   - 2.1 复制监控点前的行数据到临时表
   - 2.2 持续复制监控点后的 binlog 数据到临时表
3. **验证数据一致性**
4. **替换原表**
5. **删除临时表**

## MySQL 的主从同步

可能很多人都和我一开始一样，只知道可以主从同步，但其实完全没了解，这就是八股害人的地方了。

在 5.7 之前，主库在处理事务的时候每个事务都需要独立完成 binlog 写入，然后 fsync。为了减少这个刷盘次数，你肯定就需要 IO 聚合成批次。每一个批次是一个组，组内事务的 binlog 写入是串行的，组间是并行的。

### 第一阶段：Prepare
这些线程会竞争一个 binlog 提交的锁，获取到锁的线程将 binlog 从内存写入到磁盘，但不进行 fsync。

在这个过程中会生成一个 `sequence_number`，它是一个自增的序列号，用来标识组内事务的顺序。

### 第二阶段：Commit
一整个组进行一次 fsync，将 binlog 写入到磁盘。更新一个名为 `last_committed` 的变量，它是一个组提交的 ID。

### 第三阶段：Slave 并行复制
从库提供并行复制的能力，在同一个组当中的事务会被视作有相同的 `last_committed`，也就被从库认为我可以并行复制你进行处理。通过这个方式，每一个组就是一个逻辑上可以被视作可以并行处理的集合。

## 事故发生

在正常流程当中，主库执行 `DROP a`，再执行 `DROP a`。由于在 DROP 的过程中有 MDL 锁进行对元数据唯一的修改，导致两个操作是串行执行的，存在等待关系，第二个 DROP 会等待第一个操作，然后获得 MDL 锁。所以肯定是被放到两个不同的复制组当中，它们肯定会被串行执行。

但是有一个很诡异的情况。假设我们使用如下语句：

```sql
LOCK TABLES a WRITE, b WRITE;
```

锁住两张表，我们会获得一个 MDL 锁。

然后我们在会话1当中，执行：
```sql
DROP TABLE a;
```

这个时候它会直接释放所有的 MDL 锁！

在会话2当中，我们同样执行：
```sql
DROP TABLE a;
```

由于在会话1当中释放了 MDL 锁，所以会直接获取这个锁。也就是说，第二个 DROP 动作不需要等待 `DROP TABLE a` 对于锁的释放，二者被视作处于并行关系。

### 悲剧由此酿成

它们会被分配到同一个组当中，拥有同样的 `last_committed`。

在从库复制的过程当中，会并行执行它们。这两个线程同时对相同的元数据资源进行操作，从而引发死锁。

从库线程在执行 DDL 时，也会对内部数据字典、表缓存等资源加锁。

在底层会有一系列的锁需要在执行的过程中获取，然后释放。

假设说 `DROP a` 一共需要用到 MySQL 内部的多个锁，比如说 x、y：
- 第一个复制线程进来拿到了 x，要去获取 y
- 第二个复制线程获取了 y，要去获取 x

二者就会发生循环等待，造成死锁。这个时候从库就会因为这个两次 DROP 导致无法进入下一步，进入一个超高延时的状态，谁也无法完成 DROP。

## 解决方案

因为这个场景会出现在使用 gh-ost 进行在线修改表的场景，在机理上就是重复执行了 DROP 操作。

解决方案是在 DROP 操作上加入 `sync.Once` 确保 DROP 操作整个流程当中只会执行一次。通过这个方式避免了这个问题。

但是总的来说，由于受到 5.7 版本的桎梏，所以只能修改 gh-ost。这是个治标不治本的办法，最好的办法还是更新 MySQL 版本，如果条件允许。
